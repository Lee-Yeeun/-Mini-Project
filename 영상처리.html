<!DOCTYPE html>
<html>
  <head>
    <script lang="javascript">
          // 전역 변수부
          var inCanvas, inCtx, inPaper, inFile;
          var inImage, inH, inW;  // 중요!

          var outCanvas, outCtx, outPaper;
          var outImage, outH, outW;  // 중요!

          var gamma;

          // 함수 선언부
          function init() {
              inCanvas = document.getElementById("inCanvas"); // 도화지에 접근
              inCtx = inCanvas.getContext('2d'); // 물감, 붓이 들은 통
              outCanvas = document.getElementById("outCanvas"); // 도화지에 접근
              outCtx = outCanvas.getContext('2d'); // 물감, 붓이 들은 통
          }
          function openImage() {
              inFile = document.getElementById("inFile").files[0]; // Lena512.raw
              // (중요!) 이미지의 폭과 높이를 계산
              inH = inW = Math.floor( Math.sqrt(inFile.size));
              // 이미지 크기의 2차원 메모리 할당(확보)
              inImage = new Array(inH);
              for (var i=0; i<inH; i++)
                  inImage[i] = new Array(inW);
              // 캔버스 크기 지정
              inCanvas.height = inH;
              inCanvas.width = inW;
              // 파일 --> 메모리로 로딩
              var reader = new FileReader();
              reader.readAsBinaryString(inFile);
              reader.onload = function() {
                  var blob = reader.result; // 파일을 한 덩어리(blob)로 가져옴
                  // blob에서 한점씩 뽑아서 --> inImage 메모리 (높이x폭 반복)
                  for(var i=0; i<inH; i++) {
                      for (var k=0; k<inW; k++) {
                          var sPixel=(i*inH + k); // 시작 위치
                          var ePixel=(i*inH + k) + 1; // 끝위치
                          inImage[i][k] = blob.slice(sPixel, ePixel).charCodeAt(0); // '꽯'를 숫자(233)으로 변경;
                      }
                  }
                  displayImage();
              }

          }

          function displayImage() {
              inPaper = inCtx.createImageData(inH, inW); // 빈 종이 준비
              for(var i=0; i<inH; i++) {
                  for (var k=0; k<inW; k++) {
                          var px = inImage[i][k];
                          inPaper.data[ (i*inH +k)*4 + 0] = px; // Red
                          inPaper.data[ (i*inH +k)*4 + 1] = px; // Green
                          inPaper.data[ (i*inH +k)*4 + 2] = px; // Blue
                          inPaper.data[ (i*inH +k)*4 + 3] = 255; // Alpha
                  }
              }
              inCtx.putImageData(inPaper,0,0);// 종이를 캔버스(0,)에 붙이기

              outPaper = outCtx.createImageData(outH, outW); // 빈 종이 준비
              for(var i=0; i<outH; i++) {
                  for (var k=0; k<outW; k++) {
                      var px = outImage[i][k];
                      outPaper.data[ (i*outH +k)*4 + 0] = px; // Red
                      outPaper.data[ (i*outH +k)*4 + 1] = px; // Green
                      outPaper.data[ (i*outH +k)*4 + 2] = px; // Blue
                      outPaper.data[ (i*outH +k)*4 + 3] = 255; // Alpha
                  }
              }
              outCtx.putImageData(outPaper,0,0);// 종이를 캔버스(0,)에 붙이기
          }

              // 영상처리 알고리즘 함수부
          function selectAlgo(selNum) {
              switch (parseInt(selNum.value)) {
              case 100 :  equal_image(); break; // 동일 영상
              case 101 :  add_image(); break;
              case 103 :  reverse_image(); break;
              case 104 :  bw1_image(); break;
              case 105 :  bw2_image(); break;
              case 106 :  bw3_image(); break;
              case 107 :  gamma_image(); break;
              case 108 :  ragH_image(); break;    //RangeHighlight : 범위강조
              case 109 :  paraCap_image(); break;  //파라볼라 캡
              case 110 :  paraCup_image(); break;  //파라볼라 컵

              case 201 :  mirror1_image(); break;
              case 202 :  mirror2_image(); break;
              case 203 :  zoomOut_image(); break;
              case 204 :  zoomIn_image(); break;
              case 205 :  zoomIn2_image(); break;
              case 206 :  move_image(); break;
              case 207 :  rotation_image(); break;
              case 208 :  crop_image(); break;

              case 301 :  histoSt_image(); break; //히스토그램 스트레칭
              case 302 :  endIn_image(); break; //엔드인탐색
              case 303 :  histoEqual_image(); break; //평활화

              case 401 :  embos_image(); break; //엠보싱
              case 402 :  blur_image(); break; //블러
              case 403 :  gaussianBlur_image(); break; //가우시안 블러
              case 404 :  edge_image(); break; //경계선
              case 405 :  lapla_image(); break; //라플라
              case 406 :  dog_image(); break; //DoG
              case 407 :  log_image(); break; //Log
              case 408 :  sharp_image(); break; //샤프닝
              case 409 :  highSharpening_image(); break; //고주파 필터 샤프닝




          }
      }

      function equal_image() {
          // 중요! 출력 영상의 크기를 계산
           outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
           // 캔버스 크기 지정
           outCanvas.height = outH;
           outCanvas.width = outW;
           // ** 진짜 영상처리 알고리즘 **
           for (var i=0; i<inH; i++) {
               for (var k=0; k<inW; k++) {
                   outImage[i][k] = inImage[i][k];
              }
          }
          displayImage();
      }

      function crop_image() {
        var x_start = parseInt(prompt("x축 시작값을 입력하세요."," "));
        var x_end = parseInt(prompt("x축 끝값을 입력하세요."," "));
        var y_start = parseInt(prompt("y축 시작값을 입력하세요."," "));
        var y_end = parseInt(prompt("y축 끝값을 입력하세요."," "));
        var x=0, y=0;
          // 중요! 출력 영상의 크기를 계산
          outH = parseInt(y_end-y_start+1);
          outW = parseInt(x_end-x_start+1);

          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);

           // 캔버스 크기 지정
           outCanvas.height = outH;
           outCanvas.width = outW;

           // ** 진짜 영상처리 알고리즘 **
           for (var i=y_start; i<=y_end; i++) {
                x=0;
                for (var k=x_start; k<=x_end; k++) {
                   outImage[y][x] = inImage[i][k];
                   x++;
                }
                 y++;
          }
          displayImage();
      }


      function move_image() {
        var new_x, new_y;
        var xd = parseInt(prompt("x축으로 이동할 값을 입력하세요."," "));
        var yd = parseInt(prompt("y축으로 이동할 값을 입력하세요."," "));

          // 중요! 출력 영상의 크기를 계산
          outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
           // 캔버스 크기 지정
           outCanvas.height = outH;
           outCanvas.width = outW;
           // ** 진짜 영상처리 알고리즘 **



           for (var i=0; i<inH; i++) {
                    new_y = i+yd;

                    //y값이 유효한 좌표값인지 확인
                    if( new_y < 0 || new_y >= inH){
                     continue;
                    }
                for(var k=0; k<inW; k++){
                    new_x = k+xd;

                    //x값이 유효한 좌표값인지 확인
                    if( new_x < 0 || new_x >= inW ){
                        continue;
                    }
                    outImage[new_y][new_x] = inImage[i][k];
                }

            }

          displayImage();
      }



      function paraCap_image() {
          // 중요! 출력 영상의 크기를 계산
           outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
           // 캔버스 크기 지정
           outCanvas.height = outH;
           outCanvas.width = outW;
           // ** 진짜 영상처리 알고리즘 **
           for (var i=0; i<inH; i++) {
               for (var k=0; k<inW; k++) {
                   outImage[i][k] = 255- 255*(inImage[i][k] /127) ** 2;
              }
          }
          displayImage();
      }


      function paraCup_image() {
          // 중요! 출력 영상의 크기를 계산
           outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
           // 캔버스 크기 지정
           outCanvas.height = outH;
           outCanvas.width = outW;
           // ** 진짜 영상처리 알고리즘 **
           for (var i=0; i<inH; i++) {
               for (var k=0; k<inW; k++) {
                   outImage[i][k] = 255*(inImage[i][k]/127) ** 2;
              }
          }
          displayImage();
      }

      //범위 강조
      function ragH_image() {
        var a1 = parseInt(prompt("강조할 범위의 시작값을 입력하세요."," "));
        var a2 = parseInt(prompt("강조할 범위의 끝값을 입력하세요."," "));

          // 중요! 출력 영상의 크기를 계산
           outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
           // 캔버스 크기 지정
           outCanvas.height = outH;
           outCanvas.width = outW;
           // ** 진짜 영상처리 알고리즘 **
           for (var i=0; i<inH; i++) {
               for (var k=0; k<inW; k++) {

                if( a1<inImage[i][k] && inImage[i][k]<a2){
                    outImage[i][k] = 255;
                } else{
                    outImage[i][k] = inImage[i][k];
                }
              }
          }
          displayImage();
      }



      function embos_image() {
          // 중요! 출력 영상의 크기를 계산
          outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;
          // ** 진짜 영상처리 알고리즘 **
          // (짱! 중요)
          var mask = [    [-1.0, 0.0, 0.0],
                          [ 0.0, 0.0, 0.0],
                          [ 0.0, 0.0, 1.0] ];
          // 임시 입력 배열 (입력배열+2)
          var tmpInput = new Array(inH+2);
          for (var i=0; i<inH+2; i++)
              tmpInput[i] = new Array(inW+2);
          // 임시 입력 배열 초기화(127로)
          for (var i=0; i<inH+2; i++)
              for (var k=0; k<inW+2; k++)
                  tmpInput[i][k] = 127.0;
          // 원 입력 --> 임시 입력.. 가운데 쏙~
          for (var i=0; i<inH; i++)
              for (var k=0; k<inW; k++)
                  tmpInput[i+1][k+1] = parseFloat(inImage[i][k]);
          // 임시 출력 배열 (출력배열 크기 동일)
          var tmpOutput = new Array(outH);
          for (var i=0; i<outH; i++)
              tmpOutput[i] = new Array(outW);
          // **** 회선 연산 ***
          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  // 한 점에 대해서 처리
                  var S = 0.0;
                  for(var m=0; m<3; m++) {
                      for(var n=0; n<3; n++) {
                          S += tmpInput[i+m][k+n] * mask[m][n]
                      }
                  }
                  tmpOutput[i][k] = S;
              }
          }
          // 후처리 :마스크 합계가 0이라면 127 정도를 더하기.
          for (var i=0; i<outH; i++)
              for (var k=0; k<outW; k++)
                  tmpOutput[i][k] += 127.0;
          // 임시 출력 --> 원 출력
           for (var i=0; i<outH; i++)
              for (var k=0; k<outW; k++)
                   outImage[i][k] = parseInt(tmpOutput[i][k]);
          displayImage();
      }

      function sharp_image() {
          // 중요! 출력 영상의 크기를 계산
          outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;
          // ** 진짜 영상처리 알고리즘 **
          // (짱! 중요)
          var mask = [    [0., -1., 0.],
                          [ -1., 5.,-1.],
                          [ 0., -1., 0.] ];
          // 임시 입력 배열 (입력배열+2)
          var tmpInput = new Array(inH+2);
          for (var i=0; i<inH+2; i++)
              tmpInput[i] = new Array(inW+2);
          // 임시 입력 배열 초기화(127로)
          for (var i=0; i<inH+2; i++)
              for (var k=0; k<inW+2; k++)
                  tmpInput[i][k] = 127.0;
          // 원 입력 --> 임시 입력.. 가운데 쏙~
          for (var i=0; i<inH; i++)
              for (var k=0; k<inW; k++)
                  tmpInput[i+1][k+1] = parseFloat(inImage[i][k]);
          // 임시 출력 배열 (출력배열 크기 동일)
          var tmpOutput = new Array(outH);
          for (var i=0; i<outH; i++)
              tmpOutput[i] = new Array(outW);
          // **** 회선 연산 ***
          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  // 한 점에 대해서 처리
                  var S = 0.0;
                  for(var m=0; m<3; m++) {
                      for(var n=0; n<3; n++) {
                          S += tmpInput[i+m][k+n] * mask[m][n];
                      }
                  }
                  tmpOutput[i][k] = S;
              }
          }
          // 임시 출력 --> 원 출력
           for (var i=0; i<outH; i++)
              for (var k=0; k<outW; k++)
                   outImage[i][k] = parseInt(tmpOutput[i][k]);
          displayImage();
      }



      function blur_image() {
          // 중요! 출력 영상의 크기를 계산
          outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;
          // ** 진짜 영상처리 알고리즘 **
          // (짱! 중요)
          var mask = [    [ 1/9., 1/9., 1/9.],
                          [ 1/9., 1/9., 1/9.],
                          [ 1/9., 1/9., 1/9.] ];
          // 임시 입력 배열 (입력배열+2)
          var tmpInput = new Array(inH+2);
          for (var i=0; i<inH+2; i++)
              tmpInput[i] = new Array(inW+2);
          // 임시 입력 배열 초기화(127로)
          for (var i=0; i<inH+2; i++)
              for (var k=0; k<inW+2; k++)
                  tmpInput[i][k] = 127.0;
          // 원 입력 --> 임시 입력.. 가운데 쏙~
          for (var i=0; i<inH; i++)
              for (var k=0; k<inW; k++)
                  tmpInput[i+1][k+1] = parseFloat(inImage[i][k]);
          // 임시 출력 배열 (출력배열 크기 동일)
          var tmpOutput = new Array(outH);
          for (var i=0; i<outH; i++)
              tmpOutput[i] = new Array(outW);
          // **** 회선 연산 ***
          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  // 한 점에 대해서 처리
                  var S = 0.0;
                  for(var m=0; m<3; m++) {
                      for(var n=0; n<3; n++) {
                          S += tmpInput[i+m][k+n] * mask[m][n]
                      }
                  }
                  tmpOutput[i][k] = S;
              }
          }
          // 후처리 :마스크 합계가 0이라면 127 정도를 더하기.
      //   for (var i=0; i<outH; i++)
      //       for (var k=0; k<outW; k++)
      //           tmpOutput[i][k] += 127.0;
          // 임시 출력 --> 원 출력
          for (var i=0; i<outH; i++)
              for (var k=0; k<outW; k++)
                  outImage[i][k] = parseInt(tmpOutput[i][k]);
          displayImage();
      }

      function gaussianBlur_image() {
          // 중요! 출력 영상의 크기를 계산
          outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;
          // ** 진짜 영상처리 알고리즘 **
          // (짱! 중요)
          var mask = [    [ 1/16., 1/8., 1/16.],
                          [ 1/8., 1/4., 1/8.],
                          [ 1/16., 1/8., 1/16.] ];
          // 임시 입력 배열 (입력배열+2)
          var tmpInput = new Array(inH+2);
          for (var i=0; i<inH+2; i++)
              tmpInput[i] = new Array(inW+2);
          // 임시 입력 배열 초기화(127로)
          for (var i=0; i<inH+2; i++)
              for (var k=0; k<inW+2; k++)
                  tmpInput[i][k] = 127.0;
          // 원 입력 --> 임시 입력.. 가운데 쏙~
          for (var i=0; i<inH; i++)
              for (var k=0; k<inW; k++)
                  tmpInput[i+1][k+1] = parseFloat(inImage[i][k]);
          // 임시 출력 배열 (출력배열 크기 동일)
          var tmpOutput = new Array(outH);
          for (var i=0; i<outH; i++)
              tmpOutput[i] = new Array(outW);
          // **** 회선 연산 ***
          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  // 한 점에 대해서 처리
                  var S = 0.0;
                  for(var m=0; m<3; m++) {
                      for(var n=0; n<3; n++) {
                          S += tmpInput[i+m][k+n] * mask[m][n]
                      }
                  }
                  tmpOutput[i][k] = S;
              }
          }
          // 후처리 :마스크 합계가 0이라면 127 정도를 더하기.
      //   for (var i=0; i<outH; i++)
      //       for (var k=0; k<outW; k++)
      //           tmpOutput[i][k] += 127.0;
          // 임시 출력 --> 원 출력
          for (var i=0; i<outH; i++)
              for (var k=0; k<outW; k++)
                  outImage[i][k] = parseInt(tmpOutput[i][k]);
          displayImage();
      }




      function edge_image() {
          // 중요! 출력 영상의 크기를 계산
          outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;
          // ** 진짜 영상처리 알고리즘 **
          // (짱! 중요)
          var mask = [    [ 0., -1, 0.],
                          [ 0., -1, 0.],
                          [ 0., -1, 0.] ];
          // 임시 입력 배열 (입력배열+2)
          var tmpInput = new Array(inH+2);
          for (var i=0; i<inH+2; i++)
              tmpInput[i] = new Array(inW+2);
          // 임시 입력 배열 초기화(127로)
          for (var i=0; i<inH+2; i++)
              for (var k=0; k<inW+2; k++)
                  tmpInput[i][k] = 127.0;
          // 원 입력 --> 임시 입력.. 가운데 쏙~
          for (var i=0; i<inH; i++)
              for (var k=0; k<inW; k++)
                  tmpInput[i+1][k+1] = parseFloat(inImage[i][k]);
          // 임시 출력 배열 (출력배열 크기 동일)
          var tmpOutput = new Array(outH);
          for (var i=0; i<outH; i++)
              tmpOutput[i] = new Array(outW);
          // **** 회선 연산 ***
          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  // 한 점에 대해서 처리
                  var S = 0.0;
                  for(var m=0; m<3; m++) {
                      for(var n=0; n<3; n++) {
                          S += tmpInput[i+m][k+n] * mask[m][n]
                      }
                  }
                  tmpOutput[i][k] = S;
              }
          }
          // 후처리 :마스크 합계가 0이라면 127 정도를 더하기.
          for (var i=0; i<outH; i++)
              for (var k=0; k<outW; k++)
                  tmpOutput[i][k] += 127.0;
          // 임시 출력 --> 원 출력
          for (var i=0; i<outH; i++)
              for (var k=0; k<outW; k++)
                  outImage[i][k] = parseInt(tmpOutput[i][k]);
          displayImage();
      }

      function lapla_image() {
          // 중요! 출력 영상의 크기를 계산
          outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;
          // ** 진짜 영상처리 알고리즘 **
          // (짱! 중요)
          var mask = [    [ -1., -1., -1.],
                          [ -1., 8., -1.],
                          [ -1., -1., -1.] ];
          // 임시 입력 배열 (입력배열+2)
          var tmpInput = new Array(inH+2);
          for (var i=0; i<inH+2; i++)
              tmpInput[i] = new Array(inW+2);
          // 임시 입력 배열 초기화(127로)
          for (var i=0; i<inH+2; i++)
              for (var k=0; k<inW+2; k++)
                  tmpInput[i][k] = 127.0;
          // 원 입력 --> 임시 입력.. 가운데 쏙~
          for (var i=0; i<inH; i++)
              for (var k=0; k<inW; k++)
                  tmpInput[i+1][k+1] = parseFloat(inImage[i][k]);
          // 임시 출력 배열 (출력배열 크기 동일)
          var tmpOutput = new Array(outH);
          for (var i=0; i<outH; i++)
              tmpOutput[i] = new Array(outW);
          // **** 회선 연산 ***
          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  // 한 점에 대해서 처리
                  var S = 0.0;
                  for(var m=0; m<3; m++) {
                      for(var n=0; n<3; n++) {
                          S += tmpInput[i+m][k+n] * mask[m][n]
                      }
                  }
                  tmpOutput[i][k] = S;
              }
          }
        //   // 후처리 :마스크 합계가 0이라면 127 정도를 더하기.
        //   for (var i=0; i<outH; i++)
        //       for (var k=0; k<outW; k++)
        //           tmpOutput[i][k] += 127.0;
          // 임시 출력 --> 원 출력
          for (var i=0; i<outH; i++)
              for (var k=0; k<outW; k++)
                  outImage[i][k] = parseInt(tmpOutput[i][k]);
          displayImage();
      }



      function highSharpening_image() {
          // 중요! 출력 영상의 크기를 계산
          outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;
          // ** 진짜 영상처리 알고리즘 **
          // (짱! 중요)
          var mask = [    [ -1/9., -1/9., -1/9.],
                          [ -1/9., 8/9., -1/9.],
                          [ -1/9., -1/9., -1/9.] ];
          // 임시 입력 배열 (입력배열+2)
          var tmpInput = new Array(inH+2);
          for (var i=0; i<inH+2; i++)
              tmpInput[i] = new Array(inW+2);
          // 임시 입력 배열 초기화(127로)
          for (var i=0; i<inH+2; i++)
              for (var k=0; k<inW+2; k++)
                  tmpInput[i][k] = 127.0;
          // 원 입력 --> 임시 입력.. 가운데 쏙~
          for (var i=0; i<inH; i++)
              for (var k=0; k<inW; k++)
                  tmpInput[i+1][k+1] = parseFloat(inImage[i][k]);
          // 임시 출력 배열 (출력배열 크기 동일)
          var tmpOutput = new Array(outH);
          for (var i=0; i<outH; i++)
              tmpOutput[i] = new Array(outW);
          // **** 회선 연산 ***
          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  // 한 점에 대해서 처리
                  var S = 0.0;
                  for(var m=0; m<3; m++) {
                      for(var n=0; n<3; n++) {
                          S += 20 * tmpInput[i+m][k+n] * mask[m][n]
                      }
                  }
                  tmpOutput[i][k] = S;
              }
          }
        //   // 후처리 :마스크 합계가 0이라면 127 정도를 더하기.
        //   for (var i=0; i<outH; i++)
        //       for (var k=0; k<outW; k++)
        //           tmpOutput[i][k] += 127.0;
          // 임시 출력 --> 원 출력
          for (var i=0; i<outH; i++)
              for (var k=0; k<outW; k++)
                  outImage[i][k] = parseInt(tmpOutput[i][k]);
          displayImage();
      }



      function dog_image() {
          // 중요! 출력 영상의 크기를 계산
          outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;
          // ** 진짜 영상처리 알고리즘 **
          // (짱! 중요)
          var mask = [    [ 0., 0., -1., -1., -1., 0., 0.],
                          [ 0., -2., -3., -3., -3., -3., -2., 0.],
                          [ -1., -3., 5., 5., 5., -3., -1.],
                          [ -1., -3., 5., 16., 5., -3., -1.],
                          [ -1., -3., 5., 5., 5., -3., -1.],
                          [ 0., -2., -3., -3., -3., -3., -2., 0.],
                          [ 0., 0., -1., -1., -1., 0., 0.] ];
          // 임시 입력 배열 (입력배열+2)
          var tmpInput = new Array(inH+6);
          for (var i=0; i<inH+6; i++)
              tmpInput[i] = new Array(inW+6);
          // 임시 입력 배열 초기화(127로)
          for (var i=0; i<inH+6; i++)
              for (var k=0; k<inW+6; k++)
                  tmpInput[i][k] = 127.0;
          // 원 입력 --> 임시 입력.. 가운데 쏙~
          for (var i=0; i<inH; i++)
              for (var k=0; k<inW; k++)
                  tmpInput[i+3][k+3] = parseFloat(inImage[i][k]);
          // 임시 출력 배열 (출력배열 크기 동일)
          var tmpOutput = new Array(outH);
          for (var i=0; i<outH; i++)
              tmpOutput[i] = new Array(outW);
          // **** 회선 연산 ***
          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  // 한 점에 대해서 처리
                  var S = 0.0;
                  for(var m=0; m<7; m++) {
                      for(var n=0; n<7; n++) {
                          S += tmpInput[i+m][k+n] * mask[m][n]
                      }
                  }
                  tmpOutput[i][k] = S;
              }
          }
        //   // 후처리 :마스크 합계가 0이라면 127 정도를 더하기.
        //   for (var i=0; i<outH; i++)
        //       for (var k=0; k<outW; k++)
        //           tmpOutput[i][k] += 127.0;
          // 임시 출력 --> 원 출력
          for (var i=0; i<outH; i++)
              for (var k=0; k<outW; k++)
                  outImage[i][k] = parseInt(tmpOutput[i][k]);
          displayImage();
      }

      function log_image() {
          // 중요! 출력 영상의 크기를 계산
          outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;
          // ** 진짜 영상처리 알고리즘 **
          // (짱! 중요)
          var mask = [    [ 0., 0., -1., 0., 0.],
                          [ 0., -1., -2., -1., 0.],
                          [ -1., -2., 16., -2., -1.],
                          [ 0., -1., -2., -1., 0.],
                          [ 0., 0., -1., 0., 0.]];
          // 임시 입력 배열 (입력배열+2)
          var tmpInput = new Array(inH+4);
          for (var i=0; i<inH+4; i++)
              tmpInput[i] = new Array(inW+4);
          // 임시 입력 배열 초기화(127로)
          for (var i=0; i<inH+4; i++)
              for (var k=0; k<inW+4; k++)
                  tmpInput[i][k] = 127.0;
          // 원 입력 --> 임시 입력.. 가운데 쏙~
          for (var i=0; i<inH; i++)
              for (var k=0; k<inW; k++)
                  tmpInput[i+2][k+2] = parseFloat(inImage[i][k]);
          // 임시 출력 배열 (출력배열 크기 동일)
          var tmpOutput = new Array(outH);
          for (var i=0; i<outH; i++)
              tmpOutput[i] = new Array(outW);
          // **** 회선 연산 ***
          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  // 한 점에 대해서 처리
                  var S = 0.0;
                  for(var m=0; m<5; m++) {
                      for(var n=0; n<5; n++) {
                          S += tmpInput[i+m][k+n] * mask[m][n]
                      }
                  }
                  tmpOutput[i][k] = S;
              }
          }
        //   // 후처리 :마스크 합계가 0이라면 127 정도를 더하기.
        //   for (var i=0; i<outH; i++)
        //       for (var k=0; k<outW; k++)
        //           tmpOutput[i][k] += 127.0;
          // 임시 출력 --> 원 출력
          for (var i=0; i<outH; i++)
              for (var k=0; k<outW; k++)
                  outImage[i][k] = parseInt(tmpOutput[i][k]);
          displayImage();
      }


          function histoEqual_image() {
          // 중요! 출력 영상의 크기를 계산
          outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;
          // ** 진짜 영상처리 알고리즘 **
          // 1단계 : 히스토그램 생성
          var histo = new Array(256); // 0~255까지 픽셀 값 종류
          for( var i=0; i<256; i++) // 초기화
              histo[i] = 0;
          for (var i=0; i<inH; i++)
              for (var k=0; k<inW; k++)
                  histo[inImage[i][k]] ++;
          // 2단계 : 누적 히스토그램 생성
          var sumHisto = new Array(256); // 0~255까지 픽셀 값 종류
          for( var i=0; i<256; i++) // 초기화
              sumHisto[i] = 0;
          var sumValue = 0;
          for (var i=0; i<256; i++) {
              sumValue += histo[i];
              sumHisto[i] = sumValue;
          }
          // 3단계 : 정규화된 누적합 생성
          // normal[i] = sumHisto[i] * ( 1 / (inH*inW) ) * 255
          var normalHisto = new Array(256);
          for( var i=0; i<256; i++) // 초기화
              normalHisto[i] = 0.0;
          for( var i=0; i<256; i++) {
              normalHisto[i] = sumHisto[i] * ( 1.0 / (inH*inW) ) * 255.0;
          }
          // 최종 : 정규화된 히스토그램을 적용시켜서 픽셀값을 변환
          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  outImage[i][k] = parseInt(normalHisto[inImage[i][k]]);
              }
          }
          displayImage();
      }

      function histoSt_image() {

          // 중요! 출력 영상의 크기를 계산
          outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;
          // ** 진짜 영상처리 알고리즘 **
          //low, high 찾기 => outImage = (inImage-low)/(high-low) *255
          //버그 안생기고 최대 최소 잡는 법
          var low = inImage[0][0], high = inImage[0][0] ;

          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  if (inImage[i][k]<low){
                      low = inImage[i][k];
                  }
                  if (inImage[i][k]>high){
                      high = inImage[i][k];
                  }
              }
          }
          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  outImage[i][k]=(inImage[i][k]-low) / (high-low)*255;
              }
          }
          displayImage();
      }



      //엔드-인 탐색
      // 조금더 선명하게 해줌 histSt에 low +=50; high -=50; 만 추가
      function endIn_image() {
          // 중요! 출력 영상의 크기를 계산
          outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;
          // ** 진짜 영상처리 알고리즘 **
          //low, high 찾기 => outImage = (inImage-low)/(high-low) *255
          //버그 안생기고 최대 최소 잡는 법
          var low = inImage[0][0], high = inImage[0][0] ;

          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  if (inImage[i][k]<low){
                      low = inImage[i][k];
                  }
                  if (inImage[i][k]>high){
                      high = inImage[i][k];
                  }
              }
          }
          low +=50;
          high -=50;

          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  outImage[i][k]=(inImage[i][k]-low) / (high-low)*255;
              }
          }
          displayImage();
      }


      function rotation_image() {

          var degree = parseFloat(prompt("회전각도",45))
          var radian = degree * Math.PI / 180.0;

          // 중요! 출력 영상의 크기를 계산
          outH = parseInt(Math.cos(radian)*inH + Math.cos(Math.PI/2-radian)*inW) ;
          outW = parseInt(Math.cos(radian)*inW + Math.cos(Math.PI/2-radian)*inH);

          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);

        //outImage 초기화
        for(var i=0; i<outH; i++)
            for(var k=0; k<outW; k++)
                outImage[i][k] = String.fromCharCode(255);

          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;


          // ** 진짜 영상처리 알고리즘 **
          var xd, yd,xs,ys;

          var cx = parseInt(outH /2);
          var cy = parseInt(outW /2);


          for (var i=0; i<outH; i++) {
              for (var k=0; k<outW; k++) {
                xs = i;
                ys = k;

                  xd = parseInt(Math.cos(radian)*(xs-cx)- Math.sin(radian)*(ys-cy)+cx /outH*inH);
                  yd = parseInt(Math.sin(radian)*(xs-cx)+ Math.cos(radian)*(ys-cy)+cy /outW*inW);

                  if((0 <= xd && xd < inH) && (0 <= yd && yd< inW))
                    outImage[xs][ys] = inImage[xd][yd];
                  else
                    outImage[xs][ys] = String.fromCharCode(255);
              }
          }
          displayImage();
      }


      function gamma_image() {
          // 중요! 출력 영상의 크기를 계산
          outH = inH;
          outW = inW;
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;
          // ** 진짜 영상처리 알고리즘 **
          var value = parseInt(prompt("감마","값 -->"));
          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  outImage[i][k]=Math.trunc(((inImage[i][k]/255)**(1/value))*255);
              }
          }
          displayImage();
      }


      function zoomOut_image() {
          var scale = parseInt(prompt("축소배율", 2));
          // 중요! 출력 영상의 크기를 계산
          outH = parseInt(inH/scale);
          outW = parseInt(inW/scale);
          // 이미지 크기의 2차원 메모리 할당(확보)
          outImage = new Array(outH);
          for (var i=0; i<outH; i++)
              outImage[i] = new Array(outW);
          // 캔버스 크기 지정
          outCanvas.height = outH;
          outCanvas.width = outW;
          // ** 진짜 영상처리 알고리즘 **
          for (var i=0; i<inH; i++) {
              for (var k=0; k<inW; k++) {
                  outImage[parseInt(i/scale)][parseInt(k/scale)] = inImage[i][k];
              }
          }
          displayImage();
      }

              function zoomIn_image() {
                  var scale = parseInt(prompt("확대배율", 2));
                  // 중요! 출력 영상의 크기를 계산
                  outH = parseInt(inH*scale);
                  outW = parseInt(inW*scale);
                  // 이미지 크기의 2차원 메모리 할당(확보)
                  outImage = new Array(outH);
                  for (var i=0; i<outH; i++)
                      outImage[i] = new Array(outW);
                  // 캔버스 크기 지정
                  outCanvas.height = outH;
                  outCanvas.width = outW;
                  // ** 진짜 영상처리 알고리즘 **
                  for (var i=0; i<inH; i++) {
                      for (var k=0; k<inW; k++) {
                          outImage[parseInt(i*scale)][parseInt(k*scale)] = inImage[i][k];
                      }
                  }
                  displayImage();
              }

              function zoomIn2_image() {
                  var scale = parseInt(prompt("확대배율", 2));
                  // 중요! 출력 영상의 크기를 계산
                  outH = parseInt(inH*scale);
                  outW = parseInt(inW*scale);
                  // 이미지 크기의 2차원 메모리 할당(확보)
                  outImage = new Array(outH);
                  for (var i=0; i<outH; i++)
                      outImage[i] = new Array(outW);
                  // 캔버스 크기 지정
                  outCanvas.height = outH;
                  outCanvas.width = outW;
                  // ** 진짜 영상처리 알고리즘 **
                  for (var i=0; i<outH; i++) {
                      for (var k=0; k<outW; k++) {
                          outImage[i][k] = inImage[parseInt(i/scale)][parseInt(k/scale)];
                      }
                  }
                  displayImage();
              }

              function mirror1_image() {
                  // 중요! 출력 영상의 크기를 계산
                  outH = inH;
                  outW = inW;
                  // 이미지 크기의 2차원 메모리 할당(확보)
                  outImage = new Array(outH);
                  for (var i=0; i<outH; i++)
                      outImage[i] = new Array(outW);
                  // 캔버스 크기 지정
                  outCanvas.height = outH;
                  outCanvas.width = outW;
                  // ** 진짜 영상처리 알고리즘 **
                  for (var i=0; i<inH; i++) {
                      for (var k=0; k<inW; k++) {
                          outImage[i][inW-1-k] = inImage[i][k];
                      }
                  }
                  displayImage();
              }

              function mirror2_image() {
                  // 중요! 출력 영상의 크기를 계산
                  outH = inH;
                  outW = inW;
                  // 이미지 크기의 2차원 메모리 할당(확보)
                  outImage = new Array(outH);
                  for (var i=0; i<outH; i++)
                      outImage[i] = new Array(outW);
                  // 캔버스 크기 지정
                  outCanvas.height = outH;
                  outCanvas.width = outW;
                  // ** 진짜 영상처리 알고리즘 **
                  for (var i=0; i<inH; i++) {
                      for (var k=0; k<inW; k++) {
                          outImage[inH-1-i][k] = inImage[i][k];
                      }
                  }
                  displayImage();
              }


              function add_image() {
                  // 중요! 출력 영상의 크기를 계산
                  outH = inH;
                  outW = inW;
                  // 이미지 크기의 2차원 메모리 할당(확보)
                  outImage = new Array(outH);
                  for (var i=0; i<outH; i++)
                      outImage[i] = new Array(outW);
                  // 캔버스 크기 지정
                  outCanvas.height = outH;
                  outCanvas.width = outW;
                  // ** 진짜 영상처리 알고리즘 **
                  var value = parseInt(prompt("밝게하기", "정수값 -->"));
                  for (var i=0; i<inH; i++) {
                      for (var k=0; k<inW; k++) {
                          if (inImage[i][k] + value > 255)
                              outImage[i][k] = 255;
                          else
                              outImage[i][k] = inImage[i][k] + value;
                      }
                  }
                  displayImage();
              }

              function reverse_image() {  // 반전 영상
                  // 중요! 출력 영상의 크기를 계산
                  outH = inH;
                  outW = inW;
                  // 이미지 크기의 2차원 메모리 할당(확보)
                  outImage = new Array(outH);
                  for (var i=0; i<outH; i++)
                      outImage[i] = new Array(outW);
                  // 캔버스 크기 지정
                  outCanvas.height = outH;
                  outCanvas.width = outW;
                  // ** 진짜 영상처리 알고리즘 **
                  for (var i=0; i<inH; i++) {
                      for (var k=0; k<inW; k++) {
                          outImage[i][k] = 255 - inImage[i][k];
                      }
                  }
                  displayImage();
              }

              function bw1_image() { // 흑백 (128 기준)
                  // 중요! 출력 영상의 크기를 계산
                  outH = inH;
                  outW = inW;
                  // 이미지 크기의 2차원 메모리 할당(확보)
                  outImage = new Array(outH);
                  for (var i=0; i<outH; i++)
                      outImage[i] = new Array(outW);
                  // 캔버스 크기 지정
                  outCanvas.height = outH;
                  outCanvas.width = outW;
                  // ** 진짜 영상처리 알고리즘 **
                  for (var i=0; i<inH; i++) {
                      for (var k=0; k<inW; k++) {
                          if (inImage[i][k] > 128)
                              outImage[i][k] = 255;
                          else
                              outImage[i][k] = 0;
                      }
                  }
                  displayImage();
              }

              function bw2_image() { // 흑백 (평균값 기준)
                  // 중요! 출력 영상의 크기를 계산
                  outH = inH;
                  outW = inW;
                  // 이미지 크기의 2차원 메모리 할당(확보)
                  outImage = new Array(outH);
                  for (var i=0; i<outH; i++)
                      outImage[i] = new Array(outW);
                  // 캔버스 크기 지정
                  outCanvas.height = outH;
                  outCanvas.width = outW;
                  // ** 진짜 영상처리 알고리즘 **
                  var sum_val=0;
                  for (var i=0; i<inH; i++)
                      for (var k=0; k<inW; k++)
                          sum_val += inImage[i][k];

                  var avg_val = sum_val / (inH*inW);

                  for (var i=0; i<inH; i++) {
                      for (var k=0; k<inW; k++) {
                          if (inImage[i][k] > avg_val)
                              outImage[i][k] = 255;
                          else
                              outImage[i][k] = 0;
                      }
                  }
                  displayImage();
              }

              function bw3_image() { // 흑백 (중앙값 기준)
                  // 중요! 출력 영상의 크기를 계산
                  outH = inH;
                  outW = inW;
                  // 이미지 크기의 2차원 메모리 할당(확보)
                  outImage = new Array(outH);
                  for (var i=0; i<outH; i++)
                      outImage[i] = new Array(outW);
                  // 캔버스 크기 지정
                  outCanvas.height = outH;
                  outCanvas.width = outW;
                  // ** 진짜 영상처리 알고리즘 **
                  var tmpArray = new Array(inH*inW);
                  var index=0;
                  for (var i=0; i<inH; i++)
                      for (var k=0; k<inW; k++)
                          tmpArray[index++] = inImage[i][k];

                  tmpArray.sort();
                  var avg_val = tmpArray[parseInt((inH*inW)/2)];

                  for (var i=0; i<inH; i++) {
                      for (var k=0; k<inW; k++) {
                          if (inImage[i][k] > avg_val)
                              outImage[i][k] = 255;
                          else
                              outImage[i][k] = 0;
                      }
                  }
                  displayImage();
              }
    </script>
  </head>

  <body onload="init()">
    <h1>영상 처리 프로그램</h1>
    <form>
      <input type="file" id="inFile" onchange="openImage()" style="background-color: rgb(226, 216, 255)" font-weight: bolder /> <br />
      <select name="pixel" onchange="selectAlgo(this.form.pixel)">
        <option value="0">화소점 선택</option>
        <optgroup label="화소점 처리">
          <option value="100">동일영상</option>
          <option value="101">밝게하기</option>
          <option value="103">반전하기</option>
          <option value="104">흑백(128기준)</option>
          <option value="105">흑백(평균값 기준)</option>
          <option value="106">흑백(중앙값 기준)</option>
          <option value="107">감마</option>
          <option value="108">범위 강조</option>
          <option value="109">파라볼라(캡)</option>
          <option value="110">파라볼라(컵)</option>
        </optgroup>
      </select>
      <select name="geometry" onchange="selectAlgo(this.form.geometry)">
        <option value="0">기하학 선택</option>
        <optgroup label="기하학 처리">
          <option value="201">좌우 미러링</option>
          <option value="202">상하 미러링</option>
          <option value="203">축소</option>
          <option value="204">확대(Forwarding)</option>
          <option value="205">확대(Backwarding)</option>
          <option value="206">이동(x,y입력)</option>
          <option value="207">회전(각도입력)</option>
          <option value="208">자르기</option>
        </optgroup>
      </select>

      <select name="histogram" onchange="selectAlgo(this.form.histogram)">
        <option value="0">히스토그램 선택</option>
        <optgroup label="히스토그램 처리">
          <option value="301">히스토 스트래칭</option>
          <option value="302">엔드인 탐색</option>
          <option value="303">평활화</option>
        </optgroup>
      </select>

      <select name="area" onchange="selectAlgo(this.form.area)">
        <option value="0">화소영역 선택</option>
        <optgroup label="화소영역 처리">
          <option value="401">엠보싱</option>
          <option value="402">블러링</option>
          <option value="403">가우시안 블러링</option>
          <option value="404">경계선</option>
          <option value="405">라플라 시안</option>
          <option value="406">DoG</option>
          <option value="407">LoG</option>
          <option value="408">샤프닝</option>
          <option value="409">고주파 필터 샤프닝</option>
        </optgroup>
      </select>
    </form>
    <br />
    <canvas id="inCanvas" style="background-color: rgb(213, 228, 252)"> </canvas>
    <canvas id="outCanvas" style="background-color: rgb(255, 231, 250)"> </canvas>

    <style>
      h1 {
        color: rgb(81, 154, 196);
      }
    </style>
  </body>
</html>
